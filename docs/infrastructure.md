# Electron Website Insfrastructure and Automation Overview

The Electron website displays data from several different npm packages in addition to the content that lives in `electron/electronjs.org`. These packages are:

* [electron-i18n](https://www.npmjs.com/package/electron-i18n)
* [electron-releases](https://www.npmjs.com/package/electron-releases)
* [electron-apps](https://www.npmjs.com/package/electron-apps)
* [electron-api-historian](https://www.npmjs.com/package/electron-api-historian)

As new versions of website dependencies are published to npm, our [Dependabot setup](https://app.dependabot.com/accounts/electron/projects/11963) automatically opens PRs to update the `package.json` and `package-lock.json` as appropriate. If the dependency is one of the four packages mentioned above, Dependabot will automatically merge (and thus deploy) the new version when the PR goes green.

In addition to these packages, the data from the `electron/algolia-indices` repository is published to npm as [electron-algolia-indices](https://www.npmjs.com/package/electron-algolia-indices). This package isn't used by the website directly; instead, the index data is uploaded to Algolia's hosted search service, which is integrated into the website via Algolia's client-side search library. The npm package is for use by end-users and to run the [search example app on Heroku](https://electron-algolia.herokuapp.com/).

## `electron-i18n`

The `i18n` repo contains all the data necessary to display website content and documentation in many languages. The flow of data is as follows:

1. A GitHub Action regularly runs `npm run update-source-content`. This script pulls all the current English documentation from the stable version of `electron/electron`, as well as the [`locale.yml` file from the website repository](https://github.com/electron/electronjs.org/blob/master/data/locale.yml), and commits that data to the `master` branch.
2. The Electron [Crowdin project](https://crowdin.com/project/electron) has a GitHub integration set up via [the `glotbot` bot account](https://github.com/glotbot). Crowdin pulls the English data directly from the `electron/i18n` GitHub repository and displays it to translators to display.
3. When new translations are saved in the Crowdin UI, Crowdin (via `glotbot`) opens a PR on the `i18n` repo to update the content in that particular language. A GitHub Action automatically merges this pull request on a regular basis.
4. When a commit is made to the `master` branch of the `i18n` repo, a GitHub Action runs the tests (which builds the new `index.json` file via the `pretest` script, which is not checked in to Git, but is published to npm), and runs `npm run semantic-release`. `semantic-release` then inspects the commit messages to determine what the next version number should be, and publishes tags to GitHub and a new version of the package to npm.

## electron-releases

The `releases` repo contains information about all the Electron releases. It is used to generate the [releases page](https://electronjs.org/releases/stable) as well as the version information just underneath the hero section of the homepage.

A GitHub Action runs `npm run release` on a regular basis. This script fetches data from several places:

* Version information from the `electron` package on npm
* Version information from the `electron-nightly` package on npm
* Version information from the `electron-prebuilt` package on npm
* Release information from the GitHub Releases section of `electrion/electron`
* Dependency version information from `https://atom.io/download/electron/index.json`

It then compares this data with the old data in the repository, and if the data has changed, it commits the new data to the `master` branch and publishes a new minor version to npm.

## electron-apps

`electron-apps` is the data source for the [apps section](https://electronjs.org/apps) of the website (as well as the randomized list of apps [on the homepage](https://electronjs.org/#apps)).

Users submit their app info via a PR to the `electron/apps` repository, and every so often, a GitHub Action runs `npm run release` which fetches the latest release info and the newest version of the readme for each app, as well as analyzing color information to ensure the app looks good on the site. All this information is packed into `index.json`, which is not checked in to the repository, but is published to npm.

## electron-api-historian

The `electron-api-historian` package powers the documentation version history on the website. It is generated by searching for all the markdown files inside the `docs/` directory in `electron/electron` for the master branch and every semver-compatible tag.

A GitHub Action runs `npm run update` regularly, which clones the repo, updates the `electron` submodule, and generates the new JSON data before pushing and publishing to npm.

## electron-algolia-indices

Search on the Electron website is managed by [Algolia](https://www.algolia.com/). We generate indicies in the `electron/algolia-indices` repository and upload them to Algolia via their API to update the search results that show on the site.

A GitHub Action runs `npm run update-data-sources` on a regular basis. This script updates the `electron-apps`, `electron-i18n`, `electron-npm-packages`, and `electron-releases` npm dependencies and downloads the latest stable copy of `electron-api.json` and commits those changes to the `master` branch as `electron-bot`.

Whenever a commit is made to `master`, another GitHub Action builds the indices, runs the tests, and cuts a new release of the package via `semantic-release` and uploads the new indices to Algolia if the tests succeed. Search results on the website are updated immediately (excepting any time Algolia takes for processing the new data).

# Secrets and Secret Generation

Many of the GitHub Actions for the projects listed above require secrets to operate successfully. The secrets can be added to a repository by visiting `https://github.com/electron/<repo>/settings/secrets`, but they cannot be viewed after creating them. Here is a list of the secrets and how to generate them.

## `ALGOLIA_APPLICATION_ID` and `ALGOLIA_API_KEY`

`ALGOLIA_APPLICATION_ID` is not technically secret, but both these secrets can be accessed from the [API Keys section of the Electron Website project in Algolia](https://www.algolia.com/apps/L9LD9GHGQJ/api-keys/all). You need an invitation to the project to access this page. The API key to use is the one labeled "Write API Key".

These secrets are only used in the `electron/algolia-indices` project to upload the generated data to Algolia.

## `GH_TOKEN`

While GitHub Actions have a built-in `GITHUB_TOKEN` environment variable that actions can use to make authenticated API requests, the token scope is not customizable, and more importantly, pushes made with that token do not trigger additional workflows. For many of our projects, it's important that actions that push to `master` trigger a separate deployment workflow.

For these reasons, each project that needs access to GitHub includes a `GH_TOKEN` environment variable which is generated from the `electron-bot` account. The token has `repo` scope. Actions that need to clone and push to repositories include `$GH_TOKEN` in the clone URL, and scripts that behave this way use `set -v` so that environment variables are not auto-expanded in the script output.

To generate a new one, log in to the `electron-bot` account on GitHub (credentials and instructions for 2FA are in LastPass) and go to the [Personal Access Tokens page](https://github.com/settings/tokens). Create a new token with the `repo` scope and name it appropriately; for example, "GH_TOKEN env var for electron/i18n Actions â€” repo access".

## `NPM_TOKEN` and `NPM_AUTH_TOKEN`

Many of the projects listed in this document automatically release to npm via `semantic-release`; `NPM_TOKEN` or `NPM_AUTH_TOKEN` contains an npm token with Read and Publish permissions generated from the [npm web UI](https://www.npmjs.com/settings/electron/tokens); the credentials for the `electron` user are in LastPass. Each project uses a different token. As far as I can tell, both environment variables behave the same way (i.e. npm automatically detects it and uses it for publishing).

One big downside to npm tokens is that it is not possible to see when a token was last used, nor is it possible to name or label them, so it's dangerous to delete old tokens. We currently have several dozen such tokens.

Another thing to keep in mind is that resetting the password for the `electron` npm account will invalidate all existing tokens.
